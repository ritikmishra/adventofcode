use std::cmp::Ordering;
use std::collections::HashMap;
use std::collections::HashSet;
const SEAT_LAYOUT: &str = "LLLLLLLLL.L.LLLL.LLLL.LLLLLLLL.LLLLLLLLLLLLL.LLLL.LLLLLL.LLLL..LLLLLL.LLLLLLLL.LLLLL.LL.LLLLLLLLLL
LLLLLLLLL.LLLLLLLLLL..LLLLLLLL.LLLLLLLL.LLLL.LLLL.LLLL.LLLLLL.LLLLLLLLLLLLLLL..LL.LLLLLLLLLLLLLLLL
LLLLLLLLL.LLLLLL.LLL..LLLLLLLL.LLLLLLLL.LLLL.LLLL.LLLLLL.LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLLLLLLLLLLL.LLLLLLLL.LLLLLLLLL.LLLLLL.LLLL.LLLLLLL.LLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLL.LLLLL.LLLLLLLLLL..LLLLLLLL.LLLLLLLL.LLLL.LLLL.LLLLLL.LLLL.LLLLLLLLLLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLLLLLLLLLLLLLLLLLL.LLLLLL.LLLL.LLLL.LLLLLL.LLLLLLLLLLLL.LLLLLLL.LLLLLLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLLLLLLLLLLLLLL.L.LLLLLLLL.LLLL.LLLLLLLLLL..LLLL.L.LLLLL.LLLLLLL.LLLLLLLLL.LLLLLLLLLL
LL.LLLLLL.LLLLLL.LLLLLLLLLLL.LLLLLLLLLL.L.LLLLLLL.LLLLLL.LLLLLLLLLLLLLLLLLLLL.LLLLLLLLL.LLLL.LLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL.LL.L.LLLL.L.LLLLLLLLL.LLLLLLL.LLLLLLLLLLLLLLLLL.LLLLLLLLLL
......L.L.L....LL.L.L..L.L..LL...L......LL..L.....L.LL.LLLL.LL.L..LL........L..LL.LLL.L..L.LL.L..L
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLLLLL.L.LLLLLLLLLLLLLL.LLLLL.LLLL.LLLLLLLLLLLLLLL.LLLLLLL.L.LL.LLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL.LLLL.LLLLLLLLLLL.LLLL.LLLLLLLLLLLLLLLLLLLLLLL.L.LLLLLLLLLL
LLLLLLLLL.LLLLLLLLLLL.LLLL.LLL.LLLLL.LL.LLLLLLLLL.LLLLLL.LLL..LLLLLLLLLLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLL.LLLLLLLLLLLLLLL.LLLLLLLLLLLLL.LLLL.L.LLLL.LLLL.LLLLLLLLLLLLLLL.LLLLLLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLLLLLLL.LL.LLLLL.LLLLLLLL.LLLLLLLLL.LLLLLL.LLLL.LLLLLLL.LLLLLLL.LLLLLLL.L...LLLLLLLL
LLLLLLLLLLLLLLLL.LLLL.LLLL..LLLLLLLLLLLLLLLLLLLLL.LLLLLLLLLLL.LLLLL.LLLLLLLLL.LLLL.LLLLLLLLLLLLL.L
LLLLLLLL..LL.LLLLLLLLLLLLLLLLL.LLLLLLLL.LLLLLLLLL.LLLLLL.LLLLLLLLLLLL.LLLLLLLLLLLLLLLLL.LLLLLLLLLL
LLLLLLLL.LLL.LLLLLLLLLLLLLLLLL.LLLLLLLL.LLLL.LLLL.LLLLLL.LLLL.LLLLLLL.LLLL.LL.LLLLLLLLLLLLLLLLLLLL
LL..L.....L..L.L...LL...........LLL.L.L..L.L.....LL....LL....L...L...L..LL.L...LL.LL.LLL.L.L.LL.L.
LLLLLLL.L.LLLLLL.LLL.LLLLLLLLLLLLLLLLLL.LLLL.LL.LLLLLLLLLLLLLLLLLLLLL.LLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLL.LL.LLLL.LLLLLLLL.LLLLLLLL.LLLLLL.LL.LLLL.LLLLLL.LLLLLLL.LLLLLLLLLLLLLLLL.LLL.LLLLLLL
.LLLLLLLL.LLLLLLLLLLL.LLLLLLLL.LLLLLLLLLLLLL.LLLL.LLLLLL.LLLLLLLLLLLL.LLLLLLL.LLLLLL.LL.LLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL.LLLLLLLLL.LLLLLLLLLLLLLL.LLLL.LLLLLLL.LLLLL.LLL.LLLLL.LLLL
LLLLLLLLL.LLLLLL.LLLLLLLLLLLLL.LLLLLLLLLLLLL.LLLL.LLLLLL.L.LL.LLLLLLL.LLLLLLLLL.LLLLLLL.LLLLLLLLLL
LLLLLLLLLLLLLLLLLLLLL.LLLLLLLL.LLLLLLLLLLLLL.LLLLLLLLLLL..LLL.LLLLLLL.LLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL.L.LL.LLLLLLLLLLLLLL.LLLLLLLLL.LLLLLLLLLLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLLLLLLLLLLLLLLLL.LLLL.LLLLLLLLLLLLLLLLLLL.LLLLLLL.LLLLLLLLL.LL.LLL.LLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL..LLLLLLL.LLLL.LLLL.LLLLLLLLLLL.LLLLLLL.LLLLLLL.LLLLLLLLLLLLLLLLLLLL
.L..L..L..........L...L.LL..L...LL....LL..LL..L...L.LL.L.L..LLLL..L.L....L.......LL........L.L..L.
LLLLLLLLLLLLLLLL.LLLLLLLLLLLLL.LLLLLLLLLLLLL.LLLL.LLLLLLLLLLL.LLLL.LL.LLLLLLLLLLLLLLLLLLLLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLLLLL.LLLLL.LLLLLLLL.LLLLLL.LL.LLLLLL.LLLLLLLLLLLLLLLLLLLL.LLLLLLLLLLLLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLLLLLLLLLLLLLLL.LLLL.LLLL.LLLL.L.LLLL.LLLLLLLLLLLL.LLLLLLLLLLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL..LLL.LLLL.LLLLLLLLLLL.LLL.LLL.LLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLLLLLLL.LLLLLLLL.LLLLLLLL.LLLL.LLLL.LLLLLL.LLLL.LLLLLLL.LLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL.LLLL.LLLL.LLLLLL.LLLL.LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
LLLLLL.LL.LL.LLL.LLLL.LLLLLLLL.LLLLLLLLLLLLL.LLLL.LLLLLL.LLLL.LLLLLLL.LLLLLLL.LLLL.LL.LLLLLLLLLLLL
LLLLLLL.L.LLL..LL.LLLLLLLLLLLL.LLLLLLLLL.LLL.LLLL.LLLLL..LLLL..LLLL.L.LLLLLLL.LLLLLL.LL.LLLLLLLLLL
L.LL...L..L..L.....L...L..LL...L..LL.L.....LL.LL.L...LL.LL...L....LLL.L..LL.L.L.LL..L..LL.L.L.L..L
LLLLLLLLLLLLLLLLLLLLL.LLLLLLLL.LLLLLLLL.LLLL.LLLL.LLLLLLLLLLLLLLLLLLL.LLLLLLLLLLLLLLLLLLLLLLLLLLLL
LLLLLLLL..LLLLLL.LLLL.LLLLLLLL.LL.LLLLL.LLLL.LL.L.LLLLLL.LLLL.LLLLLLLLLLLLLLL.LLLLLLLLL.L.LLL.LLLL
LLLLLLLLLLLLLLLL.LLLLLLLLLLLLL.LLLLLLLL.LLLL.LLLL.LLLLLL.LLLL.LLLLLLL.LLLLLLL.LLLLLLLL..LLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL..LLLLLLLLLLLLLLLLLLLLLLLLLL.L.LLLLLLLLLLLLLLLLLLLLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL.LLLL.LLLL.LLLLLL..LLL.LL..L.L.LLL.LLL.LLLLLLLLL.LLLLLLLLLL
L...LLL.L......LL....L.......L..L.LLL..LL.LL.L.....LL.LL.L....L.L....LL....L....LL...L.L.....L....
LLLLLLLLL.LLLLLL.L.LL.LLLLLLLL.LLLLLLLL.LLLLLLLLLLLLLLLLLLLLL.LLLLLLL.LLLLLLL.LLLLLLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL.LLLL.LLLLLLLLLLLLLLLLLLLLL.LLLLL.LLLLLLLLLLL.LLLLLLL.LLLLLLLLLLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLLLLLLLLLLLLLLLL.LLLLLLLL.LLLL.LLLL.LLLLLLLLLLL.LLLLLLL.LLLLLLL.LLLLLLLLLLLLLLLLLLLL
LLLLLLLLL.LL.LLLLLLLL.LLL.LLLLLLLLL..LL.LLLL.LLLLLLLLLLL..L.L.LLLLLLL.LL.LLLL.LLLLLLLLL.LLLLLLLLLL
....L.L..L.L...L....L..L...L.LLL...L..LL.L..L.LL.L....L.................L...LL.LL......L...L...LL.
LLLLLLLLL.LLLLLLLLLLL.LLLLLLLLLLLLLLLLLLLLLL.LLLLLLLLLLLLLLLL.LLLLLLL.LLLLLL..LLLLLLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL.LLLL.LLLLLLLLLLLLLLLLL.LLLL.LLLL.LLLLLL.LLLL.LLLLL.LLLLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL.L.LL.LLLL.LLLL.LLLLLL.LLLLLLLLLLLLLL.LLLLLLLLLLLL.LLLLLLLL
LLLLLLLLL.LLLLLL.LLLLLLLLLLLLL.LL.LLLLL.LLLLLLLLL.LLLLLL.LLLL.LLLLLLL.LLLLLLLLLLLLLLLLLLLLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL.LLLL.LLLLLLLLLLL.LLLLLLLLLLLL.LLLLLLL.LLLLLLLLLLLLLLLLLLLL
.....L.LLLL.L.........LL.L..L...LL..LLL..L......LLL.....L.......L.LL.L.L........L...LLLLLL.L..LLL.
LLLL.LLLLLLLLLLL.LLLL.LLLLLLLLLLLLLLLLL.LLLL.LLLL.LLLLLL.LLLLLLLLLLLL.LLLLLLL.LLLLLLLLLL.LLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.L.LLLLLL.LLLLLLLLLLLLL.LL.L.LLLLLLL.LLL.L.LLLLLLLLLLLLL.LLLLLL.LL.LLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL.LLLLLLLLL.LLLLLL.LLLL.LLLLLLLLLLLLLLL.LLLLLLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL.LLLL.LLLLLLLLLLLLLLLLLLLL.LLLLLL..LLLLLLLLLL.LLLLL.L.LLLLLLL.LLLLLLLLL.LLLLL.LLLL
LLLL.....L.L...L.....L..L.L..L......LL..L...LL...L.LLL.L.L..L....L......LL.LL.L..L.L....L...LL..LL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL.LLLLLLLLLLLLLLLL.LLLLLLLLLLLLLLLLLLLL.LLLLLLLLLLLLLLLLLL.L
LLLLLLLLL.L.LLLLLLLLL.LLLLLLLL.LLLLLLLLLLLLLLLLLL.LL.LLL..LLLLLLLLLLL.L.LLLLLLLLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLLLLLLLL.LL.LLLL.LLLL.LLLLLL.LLLL.LLLLLLLLLLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLL.LL.LLLLLL.LLLLLLLLLLLLL.LLLLLLLL.LL.L..LLL.LLLLLLLLLLLLLLLLLLL.LLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLLLLLLLLLLLLLLLLLLLLLLLL..LLLLLLLLLLL.LLLL.LLLLLLL.LLLLLLLLLLLLLLL.L.LLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL.LLLL.L.LL.LLLLLL.LLLLLLLLLLLL.LLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLLLLLLLLLLLL.LLLL.LLLLLLLL.LLLLLLLL.L.LLLLLLLLLLLLLL.LLLLLLLLLLLL.LLLL.LL.LLLLLLLLLLLLLLLLLLLL
..LL.LL...L....LLLLL.....L.L..LL.L...LLLL.............L..L.LLL..........L.L...LL..LL.....LL.......
LLLLLLLLLLLLLLLLLLLLL.LLLLLLLL.LLLLLLLL.LLLL.LLLL.LLLLLL.LLLL.LLLLLLL.LLLLLLL.LL.LLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLL..LLLL.LLLLLLLLLLLLLLLLLLLLLL.LLLL.LLLLLL.LLLL.LLLLLLLLLLLLLLLLLLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLLLLLLL.LLLLLLLLLLLLLL.LL.LLLL.LLLLLLLLLLLLLLLL.LLLLLLL.LLLLLLL.LLLLLLL.LLLLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLLLLLLLLLLL.LLLLLLLLLLLLLLLLLLLLLLLLL.LLLL.LLLLLLL.LLLLLLL.LLL.LLLLL.LLL.LLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL.LLLL.LLLLLL.LLLL.LLLL.LLLLLLL.LLL.LL..LLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLLLLLLL.LLLLLLLL.LLLLLLLL.LLLL.LLLL.LLLLLL.LLLL.LLLLLLL.LLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LL.LLL.LLLL.LLLL.LLL.LLLLLLLLLLLLLLLLLL.LLLLLLLLLLL.LLLLLLLLLLLLLLLLLLLLLLLL..LLLLLLLLLL
..LLLL.LLL...LLLLL..........L...L......L..LL.....L..L..L..L.L..L..L.L..L.......L..L....LL.L.L.L.L.
LLLLLL.LL.LLLLLL.LLLL.LLLLLLLL.LLLLLLLL.LLLLLLLLL.LLL.LL.LLLL.LLLLLLL.LLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLLL.L.LLLLLLLLLLL.LLLLLLLLLLLLLLLLL.LLL..LLLL..LLLLLLLLLLLLLLLLLLLLLLLLLL.LLL.LLLLLLLLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLL.LLL.LLLLLLLLLLLLL.LLLL.LLLLLL.LLLL.LLLLLLLLLLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLLLLLLLLLLLLLLLLLLLLLLLLL.LLLL.LLLLLLLLLL.LLLLLLLL.LLLLLLLLLLLLLLLLL..LLLLLLLLL
LLLLLLLLL.LLLLLL.LLLLLLLLLLLLL.LLLLLLLL.LLLL.LLL..LLLL.LLL.LL.LLLLLLL.LLLLLLL.LLLLLLLLL.LLLLLLLLLL
LLLLLLLLL.LLLLLLLLLLLLLLLLLLLL.LLLLLLLL.LLLLLL.LL.LLLLLLLLLLL.LLLLLLLLLLLLLLL.LLLL.LLLL.LLLLLLLLLL
LLLLLLLLLLLLLLLL.LLLL.LLLLLLLL.LLLLLLLL.LLLL.LLL..LLLLLLLLLLLLLLLLLLLLLLLLLLL.LLLLLLLL...LLLLLLLLL
L.LLLLLLL.LLLLLLL.LLL.LLLLLLLLLLLLLLLLL.LLLL.LLLLLLLLLLL.LLLL.LLLLLLL.LLLLLLL.LLLLLL.LLLLLLLLLLL.L
LLLLLLL.L.LLLLLLLLLLL.LLLLLLLL.LLLLLLLLLLLLLLLLLL.LLLLLL..LLLLLLLLLL..LLLLLLL.LLLLLLLLLLLLLLLLLLLL
.LL...............L..L.L.LL...L.LL.....LL..L.LL.L.L...L.......L..L.LL..L.L...LL...L...............
LLLLLLLLL.LLLLLL..LLL.LLLLLLLL.LLLLLLLL.LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
LLLLLLLLL.LLLLLL.LLLL.LLLLLLLLLLLLL.LLL.LLLL.LLLLLLLLLLLLLLLLLLLLLLLL.LLLLLLL.LLLLLLLLLLLLLLLLLLLL
LLLLLLLLL.LLLLLLLLLLLLLLLLLLLLLLLLLLLLL.LLLL.L.LLLLLLLLLLL.LL.LLLLLLLLLLLLLLLLLLLLLLLLL.LLLLLLLLLL
LLL.LLLLLLLLLLLL.LLLL.LLLLLLLLLLLLLLLLL.L.LLL.LLLLLL.LLL.LLLL.L.LLLLL.LLLLLLLLLLLLLLLLLLLLLLLLLLLL
LLLLLLLLL.LLLLLLLLLLLLLLLLLLLL.LLLLLLLLLLLLL.LLLL.LLLLLLLL.LL.LLL.LLL.LLLLLLLLLLLLLLLLLLLLLLLLLLLL
LLLLLLLLL.LLLLLLLLLLLLL.LLLLLL.LL.LLLLL.LLLLLLLLLLLLLLLL.LLLL.LLLLLLL.LLLLLLL.LLLLLLLLL.LLLLLLLLLL
L.LLLLLLLLLLLLLLLLLLL.LLLLLLLL.LLLLLLLL.LLLL.LLLL.LLLLLL.LLLL.LLLLLL..LLLLLLL.LLLLLLLLL.LLLLLLLLLL";

#[derive(Debug, Copy, Clone)]
enum SeatState {
    FLOOR,
    EMPTY,
    OCCUPIED,
}

type SeatInfo = HashMap<(i32, i32), SeatState>;

fn parse_str_into_seat_info(seats_str: &str) -> Result<SeatInfo, (i32, i32)> {
    let mut ret = HashMap::new();
    for (row, seat_row) in seats_str.split("\n").enumerate() {
        for (col, seat) in seat_row.chars().enumerate() {
            match seat {
                '.' => ret.insert((row as i32, col as i32), SeatState::FLOOR),
                'L' => ret.insert((row as i32, col as i32), SeatState::EMPTY),
                '#' => ret.insert((row as i32, col as i32), SeatState::OCCUPIED),
                _ => return Err((row as i32, col as i32)),
            };
        }
    }
    return Ok(ret);
}

fn count_adjacent_occupied_seats(seat_info: &SeatInfo, location: (i32, i32)) -> i32 {
    let mut adjacent_occupied_seats = 0;
    for row_delta in -1..2 {
        for col_delta in -1..2 {
            if row_delta == 0 && col_delta == 0 {
                continue;
            }

            let new_location = (location.0 + row_delta, location.1 + col_delta);
            if let Some(adj_seat_status) = seat_info.get(&new_location) {
                if let SeatState::OCCUPIED = *adj_seat_status {
                    adjacent_occupied_seats += 1;
                }
            }
        }
    }
    return adjacent_occupied_seats;
}

fn print_seatinfo(seat_info: &SeatInfo) {
    let mut entries: Vec<((i32, i32), SeatState)> =
        seat_info.iter().map(|v| (*v.0, *v.1)).collect();
    entries.sort_by(|a, b| {
        let a_key = a.0;
        let b_key = b.0;
        let row_cmp = a_key.0.cmp(&b_key.0);
        match row_cmp {
            Ordering::Less => row_cmp,
            Ordering::Greater => row_cmp,
            Ordering::Equal => a_key.1.cmp(&b_key.1),
        }
    });

    let mut last_row = 0;
    for (pos, state) in entries {
        if pos.0 > last_row {
            print!("\n");
        }
        match state {
            SeatState::FLOOR => print!("."),
            SeatState::EMPTY => print!("L"),
            SeatState::OCCUPIED => print!("#"),
        };

        last_row = pos.0;
    }
    println!("\n");
}

fn los_seat_count(seat_info: &SeatInfo, location: (i32, i32)) -> i32 {
    let mut directions: HashSet<(i32, i32)> = HashSet::new();
    for row in (-1..2) {
        for col in (-1..2) {
            if row != 0 || col != 0 {
                directions.insert((row, col));
            }
        }
    }

    let mut seat_count = 0;
    let mut radius = 1;
    while directions.len() > 0 {
        let mut to_remove: Vec<(i32, i32)> = Vec::new();
        for (row_dir, col_dir) in directions.iter() {
            let new_location = (location.0 + row_dir * radius, location.1 + col_dir * radius);
            if let Some(adj_seat_status) = seat_info.get(&new_location) {
                match *adj_seat_status {
                    SeatState::OCCUPIED => {
                        seat_count += 1;
                        to_remove.push((*row_dir, *col_dir));
                    }
                    SeatState::EMPTY => {
                        to_remove.push((*row_dir, *col_dir));
                    }
                    SeatState::FLOOR => {}
                };
            } else {
                to_remove.push((*row_dir, *col_dir));
            }
        }
        for val in to_remove.iter() {
            directions.remove(&val);
        }
        to_remove.clear();
        radius += 1;
    }
    return seat_count;
}

fn single_iteration_on_behavior(seat_info: &mut SeatInfo) -> bool {
    let mut changes: SeatInfo = HashMap::new();
    for (seat_pos, seat_status) in seat_info.iter() {
        let adj_occupied_seats = los_seat_count(seat_info, *seat_pos);
        match seat_status {
            SeatState::EMPTY => {
                if adj_occupied_seats == 0 {
                    changes.insert(*seat_pos, SeatState::OCCUPIED);
                }
            }
            SeatState::FLOOR => {}
            SeatState::OCCUPIED => {
                if adj_occupied_seats >= 5 {
                    changes.insert(*seat_pos, SeatState::EMPTY);
                }
            }
        }
    }

    for (change_loc, new_val) in changes.iter() {
        seat_info.insert(*change_loc, *new_val);
    }

    print_seatinfo(seat_info);
    return changes.len() > 0;
}

fn iterate_until_steady_state(seat_info: &mut SeatInfo) -> i32 {
    let mut seats_mutated = true;
    while seats_mutated {
        seats_mutated = single_iteration_on_behavior(seat_info);
    }
    return seat_info.values().fold(0, |acc, val| {
        if let SeatState::OCCUPIED = val {
            return acc + 1;
        }
        return acc;
    });
}

pub fn day11_main() {
    match parse_str_into_seat_info(SEAT_LAYOUT,
    ) {
        Err(problem_location) => println!(
            "Unknown character located at row, col = {:?}",
            problem_location
        ),
        Ok(mut seat_info) => {
            println!(
                "at steady state, there are {} occupied seats",
                iterate_until_steady_state(&mut seat_info)
            );
        }
    }

    match parse_str_into_seat_info(
        ".............
.L.L.#.#.#.#.
.............",
    ) {
        Err(problem_location) => println!(
            "Unknown character located at row, col = {:?}",
            problem_location
        ),
        Ok(mut seat_info) => {
            print_seatinfo(&seat_info);
            println!("{:?}", seat_info.get(&(1, 3)));
            println!(
                "at steady state, there are {} occupied seats",
                los_seat_count(&mut seat_info, (1, 3))
            );
        }
    }
}
